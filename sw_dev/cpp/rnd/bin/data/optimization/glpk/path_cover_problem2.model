# GMPL model file.

# Minimum path cover problem.
#	Usage: glpsol --model path_cover_problem2.model --data path_cover_problem2.data

# Parameter.
param num_vertices, integer, >= 1;  # Number of vertices.
param num_edges, integer, >= 1;  # Number of edges.
param num_paths, integer, >= 1;  # Number of paths.

# Set.
set V := {0 .. num_vertices-1};  # Vertices.
set E, dimen 3, within {0 .. num_edges-1} cross V cross V;  # Edges: (edge index ; v1, v2).
#set EP, dimen 4, within V cross V cross V cross R;  # Edge pairs: (v1, v2, v3 ; edge smoothness).
set P{1 .. num_paths};  # Paths: edge index list.
set PC, dimen 2;  # Path costs: (path index ; path cost).

# Parameter.
#param EC{1 .. card(E)};  # Edge costs: edge weight.

# Indices.
set J := setof {(p,c) in PC} p;

# Variable.
var x{J}, binary;

#---------------------------------------------------------------------
# Objective.
minimize total_cost :
	sum {(p,c) in PC} c * x[p];

# Constraint.
s.t. edge_usage_constraint {(e,v1,v2) in E} :
	sum {j in J: e in P[j]} x[j] >= 1;

solve;

#---------------------------------------------------------------------
printf "The chosen paths:\n";
#printf {j in J: 1 == x[j]} : " %i", j;
for {j in J: 1 == x[j]}
{
	printf {p in P[j], (e,v1,v2) in E: p = e} : " %i(%i,%i),", e, v1, v2;
	printf "\n";
}
printf "\n";

printf "The edge usage counts:\n";
for {(e,v1,v2) in E}
{
	printf " %i (%i,%i): %i", e, v1, v2, sum {j in J: e in P[j]} x[j];
	printf "\n";
}
printf "\n";

end;
