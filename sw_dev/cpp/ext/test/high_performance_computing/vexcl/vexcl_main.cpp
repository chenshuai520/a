//#define VEXCL_SHOW_KERNELS
//#define VEXCL_BACKEND_OPENCL  // Default.
#define VEXCL_BACKEND_COMPUTE
//#define VEXCL_BACKEND_CUDA
#include <vexcl/vexcl.hpp>
#include <boost/numeric/odeint.hpp>
#include <sstream>
#include <iostream>
#include <set>
#include <vector>
#include <array>
#include <string>
#include <stdexcept>


namespace {
namespace local {

// REF [file] >> ${VEC_HOME}/examples/devlist.cpp
void devlist_example()
{
#if defined(VEXCL_BACKEND_OPENCL)
	try
	{
        std::cout << "OpenCL devices:" << std::endl << std::endl;
        const auto dev = vex::device_list(vex::Filter::All);
        for (auto d = dev.begin(); d != dev.end(); ++d)
        {
            std::cout << "  " << d->getInfo<CL_DEVICE_NAME>() << std::endl
                << "    " << std::left << std::setw(32) << "CL_PLATFORM_NAME" << " = "
                << cl::Platform(d->getInfo<CL_DEVICE_PLATFORM>()).getInfo<CL_PLATFORM_NAME>()
                << std::endl;

#define SHOW_DEVPROP(name) \
    std::cout << "    " << std::left << std::setw(32) << #name << " = " << d->getInfo<name>() << std::endl

            SHOW_DEVPROP(CL_DEVICE_VENDOR);
            SHOW_DEVPROP(CL_DEVICE_MAX_COMPUTE_UNITS);
            SHOW_DEVPROP(CL_DEVICE_HOST_UNIFIED_MEMORY);
            SHOW_DEVPROP(CL_DEVICE_GLOBAL_MEM_SIZE);
            SHOW_DEVPROP(CL_DEVICE_LOCAL_MEM_SIZE);
            SHOW_DEVPROP(CL_DEVICE_MAX_MEM_ALLOC_SIZE);
            SHOW_DEVPROP(CL_DEVICE_MAX_CLOCK_FREQUENCY);

#undef SHOW_DEVPROP

            std::cout << "    " << std::left << std::setw(32) << "CL_DEVICE_EXTENSIONS" << " = ";
            {
                std::istringstream iss(d->getInfo<CL_DEVICE_EXTENSIONS>());
                std::set<std::string> extensions;

                extensions.insert(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>());

                size_t w = 40;
                for (auto s = extensions.begin(); s != extensions.end(); ++s)
                {
                    w += s->length() + 1;
                    if (w > 80)
                    {
                        std::cout << std::endl << std::setw(w = 8) << "";
                        w += s->length() + 1;
                    }
                    std::cout << *s << " ";
                }
            }
            std::cout << std::endl << std::endl;
        }
	}
	catch (const cl::Error &ex)
	{
		std::cerr << "cl::Error caught: " << ex << std::endl;
	}
#else
    std::cout << "The backend of VexCL is not OpenCL." << std::endl;
#endif
}

// REF [file] >> ${VEC_HOME}/examples/exclusive.cpp
void exclusive_example()
{
	// Get exclusive access to compute devices.
	vex::Context ctx(vex::Filter::Exclusive(vex::Filter::Env));

	if (ctx.size())
		std::cout << "Locked devices:" << std::endl
			<< ctx << std::endl
			<< "Press any key to exit: " << std::endl;
	else
		std::cout << "No available devices found." << std::endl;
}

typedef double value_type;
#if defined(_WIN64) || defined(WIN32)
typedef vex::generator::symbolic<value_type> sym_value_type;
#else
typedef vex::symbolic<value_type> sym_value_type;
#endif
typedef std::array<sym_value_type, 3> sym_state_type;

// REF [file] >> ${VEC_HOME}/examples/symbolic.cpp
// System function for Lorenz attractor ensemble ODE.
// [1] http://headmyshoulder.github.com/odeint-v2/doc/boost_numeric_odeint/tutorial/chaotic_systems_and_lyapunov_exponents.html
// This is only used to record operations chain for autogenerated kernel.
struct sys_func
{
	const value_type sigma;
	const value_type b;
	const sym_value_type &R;

	sys_func(value_type sigma, value_type b, const sym_value_type &R)
	: sigma(sigma), b(b), R(R)
	{}

	template <class Sig>
	struct result
	{
		typedef void type;
	};

	void operator()(const sym_state_type &x, sym_state_type &dxdt, value_type) const
	{
		dxdt[0] = sigma * (x[1] - x[0]);
		dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
		dxdt[2] = x[0] * x[1] - b * x[2];
	}
};

// REF [file] >> ${VEC_HOME}/examples/symbolic.cpp
void symbolic_example()
{
	const value_type dt = 0.01;
	const value_type t_max = 100.0;

	const size_t n = 1024;

	vex::Context ctx(vex::Filter::Exclusive(vex::Filter::DoublePrecision && vex::Filter::Env));
	if (!ctx) throw std::runtime_error("No devicess with double precision found");
	std::cout << ctx << std::endl;

	// Custom kernel body will be recorded here.
	std::ostringstream body;
	vex::generator::set_recorder(body);

	// State types that would become kernel parameters.
	sym_state_type symState = {{
		sym_value_type::VectorParameter,
		sym_value_type::VectorParameter,
		sym_value_type::VectorParameter
	}};

	// Const kernel parameter.
	sym_value_type symR(sym_value_type::VectorParameter, sym_value_type::Const);

	// Symbolic stepper.
	boost::numeric::odeint::runge_kutta4<
		sym_state_type, value_type, sym_state_type, value_type,
		boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations
	> sym_stepper;

	sys_func sys(10.0, 8.0 / 3.0, symR);
	sym_stepper.do_step(std::ref(sys), symState, 0, dt);

	auto kernel = vex::generator::build_kernel(ctx, "lorenz", body.str(), symState[0], symState[1], symState[2], symR);

	// Real state initialization.
	const value_type Rmin = 0.1;
	const value_type Rmax = 50.0;
	const value_type dR = (Rmax - Rmin) / (n - 1);

	vex::vector<value_type> X(ctx, n);
	vex::vector<value_type> Y(ctx, n);
	vex::vector<value_type> Z(ctx, n);
	vex::vector<value_type> R(ctx, n);

	X = 10.0;
	Y = 10.0;
	Z = 10.0;
	R = Rmin + dR * vex::element_index();  // Run-time error.

	// Integration loop.
	for (value_type t = 0; t < t_max; t += dt)
		kernel(X, Y, Z, R);

	std::vector<value_type> result(n);
	vex::copy(X, result);
	std::cout << result[0] << std::endl;
}

}  // namespace local
}  // unnamed namespace

namespace my_vexcl {

}  // namespace my_vexcl

int vexcl_main(int argc, char *argv[])
{
    local::devlist_example();
    //local::exclusive_example();
    //local::symbolic_example();  // Run-time error.

    return 0;
}
